/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  ChatGptResponseView: () => ChatGptResponseView,
  VIEW_TYPE_CHATGPT_RESPONSE: () => VIEW_TYPE_CHATGPT_RESPONSE,
  default: () => PromptGptPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  api_key: "",
  tags: [],
  path_to_prompt_template: [],
  chatgpt_behavior: "You are a helpful assistant.",
  convo_retention: 10,
  conversations: {},
  last_convo: { conversations: [{ role: "system", content: "You are a helpful assistant" }], last_updated: new Date().getTime() }
};
var VIEW_TYPE_CHATGPT_RESPONSE = "chatgpt-response-view";
var ChatGptResponseView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_CHATGPT_RESPONSE;
  }
  getDisplayText() {
    return this.display_text;
  }
  setDisplayText(conversation) {
    this.conversation = conversation;
    const container = this.containerEl.children[1];
    container.empty();
    let containerEl = container.createEl("div", { text: "ChatGPT" });
    this.createChatUI(containerEl);
  }
  async onOpen() {
    await this.plugin.loadSettings();
    this.conversation = this.plugin.settings.last_convo;
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("main-container");
    let containerEl = container.createEl("div", { text: "ChatGPT" });
    this.createChatUI(containerEl);
  }
  async onClose() {
    this.plugin.setLastConvo(this.conversation);
  }
  createChatUI(container) {
    const linebreak = container.createEl("div");
    linebreak.addClass("line-break");
    container.appendChild(linebreak);
    const chatDiv = container.createEl("div");
    chatDiv.addClass("chat-container");
    container.appendChild(chatDiv);
    const inputBox = container.createEl("input");
    inputBox.type = "text";
    inputBox.placeholder = "Type your message...";
    inputBox.addClass("input-box");
    if (this.conversation) {
      this.displayConversation(chatDiv);
    }
    inputBox.addEventListener("keyup", (event) => {
      if (event.key === "Enter") {
        const userInput = inputBox.value;
        if (userInput) {
          this.conversation.conversations.push({ role: "user", content: userInput });
          this.displayConversation(chatDiv);
          inputBox.value = "";
          this.plugin.callChatGPT(this.conversation).then(() => {
            this.displayConversation(chatDiv);
          });
        } else {
          new import_obsidian.Notice("Please enter a message.");
        }
      }
    });
    container.appendChild(inputBox);
    return container;
  }
  displayConversation(chatDiv) {
    this.conversation.conversations.map((msg) => {
      let div = chatDiv.createEl("div");
      let strong = div.createEl("strong", { text: this.capitalizeFirstLetter(msg.role) + "\n\n" });
      let formattedEl = this.formatContent(chatDiv, msg.content);
      div.appendChild(strong);
      div.appendChild(formattedEl);
      chatDiv.appendChild(div);
    });
    chatDiv.scrollTop = chatDiv.scrollHeight;
  }
  capitalizeFirstLetter(s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
  }
  formatContent(chatDiv, content) {
    let innerDiv = chatDiv.createEl("ul");
    const lines = content.split("\n");
    const listItems = lines.map((line) => {
      innerDiv.appendChild(innerDiv.createEl("span", { text: line }));
      innerDiv.appendChild(innerDiv.createEl("br"));
    });
    return innerDiv;
  }
};
var PromptGptPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.loaded = true;
    //setting limit to 5000 characters, hopefully reduce amount of instances where user hits the api limit 
    //(max is 150,000 tokens per minute)
    this.max_context_length = 5e3;
  }
  setLastConvo(convo) {
    this.settings.last_convo = convo;
  }
  async onload() {
    await this.loadSettings();
    this.conversations = new Map(Object.entries(this.settings.conversations));
    this.addSettingTab(new SettingTab(this.app, this));
    this.addRibbonIcon("brain-circuit", "Show/Hide ChatGPT", () => {
      const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_CHATGPT_RESPONSE);
      if (leaves.length > 0) {
        this.deactivateView();
        this.loaded = false;
      } else {
        this.activateView().then(() => {
          this.loaded = true;
        });
      }
    });
    this.registerView(
      VIEW_TYPE_CHATGPT_RESPONSE,
      (leaf) => new ChatGptResponseView(leaf, this)
    );
    this.registerEvent(this.app.workspace.on("file-open", (file) => {
      if (!this.loaded) {
        return;
      }
      if (file) {
        if (file.name.substring(file.name.length - 3) !== ".md") {
          return;
        }
        if (this.conversations.has(file.name)) {
          this.app.workspace.getLeavesOfType(VIEW_TYPE_CHATGPT_RESPONSE).forEach((leaf) => {
            if (leaf.view instanceof ChatGptResponseView) {
              leaf.view.setDisplayText(this.conversations.get(file.name));
            }
          });
          return;
        }
        const file_cache = this.app.metadataCache.getFileCache(file);
        if (!file_cache) {
          return;
        }
        let tags = (0, import_obsidian.getAllTags)(file_cache);
        if (!tags) {
          return;
        }
        this.settings.tags.every((tag) => {
          if (tags.includes("#" + tag)) {
            this.getPromptText(tag).then((prompt) => {
              if (!prompt) {
                return true;
              }
              let starter_convo = [{ role: "system", content: this.settings.chatgpt_behavior }];
              this.conversations.set(file.name, { last_updated: new Date().getTime(), conversations: starter_convo });
              this.addPlaceholdersToPrompt(prompt, file.name, file).then((prompt2) => {
                this.conversations.get(file.name).conversations.push({ role: "user", content: prompt2 });
                this.app.workspace.getLeavesOfType(VIEW_TYPE_CHATGPT_RESPONSE).forEach((leaf) => {
                  if (leaf.view instanceof ChatGptResponseView) {
                    leaf.view.setDisplayText(this.conversations.get(file.name));
                  }
                });
                this.callChatGPT(this.conversations.get(file.name)).then(() => {
                  this.app.workspace.getLeavesOfType(VIEW_TYPE_CHATGPT_RESPONSE).forEach((leaf) => {
                    if (leaf.view instanceof ChatGptResponseView) {
                      leaf.view.setDisplayText(this.conversations.get(file.name));
                    }
                  });
                  return true;
                });
              });
            });
          }
        });
      }
    }, ""));
    let date_today = new Date();
    let keysToRemove = [];
    for (let [key, value] of this.conversations) {
      let diffTime = Math.abs(date_today.getTime() - value.last_updated);
      const diffDays = Math.ceil(diffTime / (1e3 * 60 * 60 * 24));
      if (diffDays > this.settings.convo_retention) {
        keysToRemove.push(key);
      }
    }
    keysToRemove.forEach((element) => {
      this.conversations.delete(element);
    });
  }
  async callChatGPT(dated_conversation) {
    let cur_conversation = dated_conversation.conversations;
    if (this.settings.api_key == "") {
      new import_obsidian.Notice("Please add an api key to the settings");
      return;
    }
    try {
      const apiKey = this.settings.api_key;
      const apiUrl = "https://api.openai.com/v1/chat/completions";
      const response = await (0, import_obsidian.requestUrl)({
        url: apiUrl,
        method: "POST",
        contentType: "application/json",
        headers: {
          "Authorization": `Bearer ${apiKey}`
        },
        body: JSON.stringify({
          model: "gpt-3.5-turbo",
          messages: cur_conversation
        })
      });
      const modelReply = response.json.choices[0].message.content;
      cur_conversation.push({ role: "assistant", content: modelReply });
      dated_conversation.last_updated = new Date().getTime();
    } catch (error) {
      console.error("Error interacting with ChatGPT API:", error.message);
      if (error.message.includes("429")) {
        new import_obsidian.Notice("Quota from ChatGPT has been exceeded. Either: \n 1. Too many requests per minute were sent. \n 2. You reached your monthly limit");
      }
    }
  }
  async activateView() {
    const { workspace } = this.app;
    this.oldWorkspace = workspace;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_CHATGPT_RESPONSE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      await leaf.setViewState({ type: VIEW_TYPE_CHATGPT_RESPONSE, active: true });
    }
    workspace.revealLeaf(leaf);
  }
  async deactivateView() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_CHATGPT_RESPONSE);
    if (leaves.length > 0) {
      let leaf = leaves[0];
      leaf.detach();
    }
  }
  async getPromptText(tag) {
    const path = this.settings.path_to_prompt_template[this.settings.tags.indexOf(tag)];
    const tfile = this.app.metadataCache.getFirstLinkpathDest(path, path);
    if (!tfile) {
      console.error("Prompt template doesn't exist");
      return null;
    }
    return this.app.vault.cachedRead(tfile);
  }
  async addPlaceholdersToPrompt(prompt, filename, currentFile) {
    let promptText = prompt.replace("{{title}}", filename.substring(0, filename.length - 3));
    if (promptText.contains("{{context}}")) {
      const full_file = await this.app.vault.cachedRead(currentFile);
      promptText = promptText.replace("{{context}}", full_file.substring(0, Math.min(full_file.length, this.max_context_length)));
      return promptText;
    }
    return promptText;
  }
  async onunload() {
    this.settings.conversations = Object.fromEntries(this.conversations);
    await this.saveSettings();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var SettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("API key").setDesc("Get your api key from: https://platform.openai.com/api-keys.").addText((text) => text.setPlaceholder("Enter api key").setValue("****************").onChange(async (value) => {
      this.plugin.settings.api_key = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Tags to research").setDesc("The tags you want ChatGPT to run on when note is opened.").addText((text) => text.setPlaceholder("tag1,tag2,tag3").setValue(this.plugin.settings.tags.join(",")).onChange(async (value) => {
      this.plugin.settings.tags = value.split(",");
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Prompt templates for each tag").setDesc("The templates to use corresponding to the order of the tags above.").addText((text) => text.setPlaceholder("path1,path2,path3").setValue(this.plugin.settings.path_to_prompt_template.join(",")).onChange(async (value) => {
      this.plugin.settings.path_to_prompt_template = value.split(",").map((m) => (0, import_obsidian.normalizePath)(m));
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("ChatGPT's behavior").setDesc("How do you want it to act?").addText((text) => text.setPlaceholder("You are a helpful assistant.").setValue(this.plugin.settings.chatgpt_behavior).onChange(async (value) => {
      this.plugin.settings.chatgpt_behavior = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Conversation retention").setDesc("How many days to hold conversations before deleting.").addText((text) => text.setPlaceholder("10").setValue(String(this.plugin.settings.convo_retention)).onChange(async (value) => {
      this.plugin.settings.convo_retention = Math.min(Number(value), 30);
      await this.plugin.saveSettings();
    }));
  }
};


/* nosourcemap */